---
export interface GalleryImage {
  src: string;
  alt: string;
}

export interface Props {
  images: GalleryImage[];
  galleryName: string;
}

const { images, galleryName } = Astro.props;
---

<div class="gallery-container">
  <div class="masonry-gallery" id="masonryGallery">
    {
      images.map((image, index) => (
        <div class="masonry-item animate-content-fast" style={`animation-delay: ${1.2 + index * 0.1}s`}>
          <button
            class="gallery-link gallery-image-btn"
            data-gallery={galleryName}
            data-src={image.src}
            data-alt={image.alt}
            data-index={index}
            type="button"
          >
            <div class="image-container">
              <img
                class="gallery-image lazy-image"
                data-src={image.src}
                alt={image.alt}
                loading="lazy"
              />
              <div class="image-overlay">
                <div class="overlay-content">
                  <svg
                    class="expand-icon"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                  >
                    <path
                      fill="currentColor"
                      d="M15 3h6v6l-2-2-4 4-2-2 4-4-2-2zM9 21H3v-6l2 2 4-4 2 2-4 4 2 2z"
                    />
                  </svg>
                </div>
              </div>
            </div>
          </button>
        </div>
      ))
    }

    <slot />
  </div>
</div>

<script>
  class LazyImageLoader {
    private observer: IntersectionObserver | null;
    private loadedImages: Set<string>;

    constructor() {
      this.observer = null;
      this.loadedImages = new Set();
      this.init();
    }

    init() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const img = entry.target as HTMLImageElement;
              const src = img.dataset.src;
              if (src && !this.loadedImages.has(src)) {
                this.loadImage(img, src);
              }
            }
          });
        },
        {
          rootMargin: "50px 0px",
          threshold: 0.1,
        }
      );

      this.observeImages();
    }

    loadImage(img: HTMLImageElement, src: string) {
      img.classList.add("loading");

      const tempImg = new Image();
      tempImg.onload = () => {
        img.src = src;
        img.classList.remove("loading");
        img.classList.add("loaded");
        this.loadedImages.add(src);
        this.observer?.unobserve(img);
      };

      tempImg.onerror = () => {
        img.classList.remove("loading");
        console.warn(`Failed to load image: ${src}`);
        this.observer?.unobserve(img);
      };

      tempImg.src = src;
    }

    observeImages() {
      const lazyImages = document.querySelectorAll(".lazy-image");
      lazyImages.forEach((img) => {
        if (this.observer) {
          this.observer.observe(img);
        }
      });
    }

    refresh() {
      this.observeImages();
    }
  }

  // Initialize gallery with custom lightbox
  function initializeGallery() {
    new LazyImageLoader();
    setupCustomLightbox();
  }

  function setupCustomLightbox() {
    // Import the lightbox manager
    import('../../utils/LightboxManager.ts').then(({ LightboxManager }) => {
      const lightboxManager = LightboxManager.getInstance();
      
      // Group gallery images and text items by gallery name
      const allImageButtons = Array.from(document.querySelectorAll('.gallery-image-btn'));
      const allTextButtons = Array.from(document.querySelectorAll('.text-lightbox-btn'));
      const galleriesByName = new Map();
      
      // Process image buttons
      allImageButtons.forEach((btn, globalIndex) => {
        const galleryName = btn.getAttribute('data-gallery') || '';
        if (!galleriesByName.has(galleryName)) {
          galleriesByName.set(galleryName, []);
        }
        galleriesByName.get(galleryName).push({
          button: btn,
          globalIndex,
          content: {
            type: 'image' as const,
            src: btn.getAttribute('data-src') || '',
            alt: btn.getAttribute('data-alt') || '',
            galleryName,
            index: galleriesByName.get(galleryName).length
          }
        });
      });

      // Process text lightbox buttons and add them to their respective galleries
      allTextButtons.forEach((btn) => {
        const galleryName = btn.getAttribute('data-gallery') || '';
        const href = btn.getAttribute('data-href');
        
        if (galleryName && href) {
          const targetElement = document.querySelector(href);
          if (targetElement) {
            if (!galleriesByName.has(galleryName)) {
              galleriesByName.set(galleryName, []);
            }
            galleriesByName.get(galleryName).push({
              button: btn,
              globalIndex: -1, // Text items don't have a global index
              content: {
                type: 'html' as const,
                element: targetElement as HTMLElement,
                galleryName,
                index: galleriesByName.get(galleryName).length
              }
            });
          }
        }
      });

      // Register each gallery separately and add click handlers
      galleriesByName.forEach((items, galleryName) => {
        if (galleryName) {
          const galleryContent = items.map(item => item.content);
          lightboxManager.registerGallery(galleryName, galleryContent);
          
          // Add click handlers for this specific gallery
          items.forEach((item) => {
            item.button.addEventListener('click', (e) => {
              e.preventDefault();
              lightboxManager.open(item.content);
            });
          });
        }
      });
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeGallery);
  } else {
    initializeGallery();
  }

  document.addEventListener("astro:after-swap", initializeGallery);
</script>