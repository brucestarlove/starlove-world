---
export interface Props {
  playlist?: { title: string; src: string }[];
  autoplay?: boolean;
  volume?: number;
  className?: string;
  id?: string;
}

const {
  playlist = [
    {
      title: "lavitz-harpoon.wave",
      src: "/audio/Lavitz_Harpoon_Full.mp3",
    },
  ],
  autoplay = false,
  volume = 1.0,
  className = "",
  id = "starscape-audio-player",
} = Astro.props;

const playerId = `${id}-${Math.random().toString(36).substring(2, 11)}`;
---

<div class={`starscape-audio-player ${className}`} data-player-id={playerId}>
  <button class="player-btn prev-btn" data-btn="prev">
    <svg viewBox="0 0 24 24" width="16" height="16">
      <path fill="currentColor" d="M6,18V6H8V18H6M9.5,12L18,6V18L9.5,12Z"
      ></path>
    </svg>
  </button>

  <button class="player-btn play-pause-btn" data-btn="play-pause">
    <svg class="play-icon" viewBox="0 0 24 24" width="18" height="18">
      <path fill="currentColor" d="M8,5.14V19.14L19,12.14L8,5.14Z"></path>
    </svg>
    <svg
      class="pause-icon"
      viewBox="0 0 24 24"
      width="18"
      height="18"
      style="display: none;"
    >
      <path fill="currentColor" d="M14,19H18V5H14M6,19H10V5H6V19Z"></path>
    </svg>
  </button>

  <button class="player-btn next-btn" data-btn="next">
    <svg viewBox="0 0 24 24" width="16" height="16">
      <path fill="currentColor" d="M16,18H18V6H16M6,18L14.5,12L6,6V18Z"></path>
    </svg>
  </button>

  <div class="track-info">
    <span class="track-title" data-element="track-title">No track loaded</span>
    <div class="progress-container">
      <span class="time-current" data-element="time-current">0:00</span>
      <div class="progress-bar" data-element="progress-bar">
        <div class="progress-fill" data-element="progress-fill"></div>
        <div class="progress-handle" data-element="progress-handle"></div>
      </div>
      <span class="time-total" data-element="time-total">0:00</span>
    </div>
  </div>

  <div class="playlist-control" data-element="playlist-control">
    <button class="player-btn playlist-btn" data-btn="playlist">
      <svg class="playlist-icon" viewBox="0 0 24 24" width="16" height="16">
        <path
          fill="currentColor"
          d="M15,6H3V8H15V6M15,10H3V12H15V10M3,16H11V14H3V16M17,6V14.18C16.69,14.07 16.35,14 16,14A3,3 0 0,0 13,17A3,3 0 0,0 16,20A3,3 0 0,0 19,17V8H22V6H17Z"
        ></path>
      </svg>
    </button>

    <div class="playlist-tooltip" data-element="playlist-tooltip">
      <div class="playlist-header">
        <span>Playlists</span>
      </div>
      <div class="playlist-list" data-element="playlist-list">
        <!-- Playlist items will be populated by JavaScript -->
      </div>
    </div>
  </div>

  <div class="volume-control" id="volumeControl">
    <button class="player-btn volume-btn" data-btn="volume">
      <svg class="volume-icon" viewBox="0 0 24 24" width="16" height="16">
        <path
          fill="currentColor"
          d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.85 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"
        ></path>
      </svg>
    </button>

    <div class="volume-tooltip" data-element="volume-tooltip">
      <div class="volume-slider-container">
        <div class="volume-slider" data-element="volume-slider">
          <div class="volume-fill" data-element="volume-fill"></div>
          <div class="volume-handle" data-element="volume-handle"></div>
        </div>
        <span class="volume-percentage" data-element="volume-percentage"
          >100%</span
        >
      </div>
    </div>
  </div>
</div>

<style>
  /* Starscape Simple Audio Player Styles */
  .starscape-audio-player {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    background: var(--secondary-bg, #1e293b);
    border: 1px solid var(--border-color, #334155);
    border-radius: 8px;
    padding: 0.5rem 0.75rem;
    min-width: 0;
    flex: 1;
    max-width: 400px;
    color: var(--text-primary, #f1f5f9);
    font-family: system-ui, sans-serif;
  }

  .player-btn {
    background: none;
    border: none;
    color: var(--text-secondary, #e1e1e1);
    cursor: pointer;
    padding: 0.25rem;
    border-radius: 4px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .player-btn:hover {
    background: var(--accent-bg, #3b82f6);
    color: white;
  }

  .play-pause-btn {
    background: var(--accent-bg, #3b82f6);
    color: white;
    padding: 0.5rem;
    border-radius: 6px;
  }

  .play-pause-btn:hover {
    background: var(--glow-color, #60a5fa);
  }

  .track-info {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .track-title {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--text-primary, #f1f5f9);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .progress-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .time-current,
  .time-total {
    font-size: 0.7rem;
    color: var(--text-secondary, #e1e1e1);
    font-variant-numeric: tabular-nums;
    flex-shrink: 0;
  }

  .progress-bar {
    flex: 1;
    height: 4px;
    background: var(--border-color, #334155);
    border-radius: 2px;
    position: relative;
    cursor: pointer;
    min-width: 60px;
  }

  .progress-fill {
    height: 100%;
    background: var(--accent-bg, #3b82f6);
    border-radius: 2px;
    width: 0%;
    transition: width 0.1s ease;
  }

  .progress-handle {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 12px;
    height: 12px;
    background: var(--accent-bg, #3b82f6);
    border: 2px solid white;
    border-radius: 50%;
    cursor: grab;
    opacity: 0;
    transition: opacity 0.2s ease;
    left: 0%;
  }

  .progress-bar:hover .progress-handle {
    opacity: 1;
  }

  .progress-handle:active {
    cursor: grabbing;
    transform: translate(-50%, -50%) scale(1.2);
  }

  /* Volume Control Styles */
  .volume-control {
    position: relative;
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }

  .volume-btn {
    position: relative;
  }

  .volume-tooltip {
    position: absolute;
    bottom: calc(100% + 10px);
    left: 50%;
    transform: translateX(-50%);
    background: var(--secondary-bg, #1e293b);
    border: 1px solid var(--border-color, #334155);
    border-radius: 8px;
    padding: 0.75rem;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
    z-index: 1000;
    min-width: 120px;
  }

  .volume-tooltip::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: var(--border-color, #334155);
  }

  .volume-tooltip::before {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: var(--secondary-bg, #1e293b);
    z-index: 1;
  }

  .volume-control:hover .volume-tooltip {
    opacity: 1;
    visibility: visible;
  }

  .volume-slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
  }

  .volume-slider {
    width: 80px;
    height: 4px;
    background: var(--border-color, #334155);
    border-radius: 2px;
    position: relative;
    cursor: pointer;
  }

  .volume-fill {
    height: 100%;
    background: var(--accent-bg, #3b82f6);
    border-radius: 2px;
    width: 100%;
    transition: width 0.1s ease;
  }

  .volume-handle {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 12px;
    height: 12px;
    background: var(--accent-bg, #3b82f6);
    border: 2px solid white;
    border-radius: 50%;
    cursor: grab;
    left: 100%;
  }

  .volume-handle:active {
    cursor: grabbing;
    transform: translate(-50%, -50%) scale(1.2);
  }

  .volume-percentage {
    font-size: 0.7rem;
    color: var(--text-secondary, #e1e1e1);
    font-variant-numeric: tabular-nums;
  }

  /* Playlist Control Styles */
  .playlist-control {
    position: relative;
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }

  .playlist-btn {
    position: relative;
  }

  .playlist-tooltip {
    position: absolute;
    bottom: calc(100% + 10px);
    left: 50%;
    transform: translateX(-50%);
    background: var(--secondary-bg, #1e293b);
    border: 1px solid var(--border-color, #334155);
    border-radius: 8px;
    padding: 0;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
    z-index: 1000;
    min-width: 280px;
    max-width: 320px;
    max-height: 400px;
    overflow-y: auto;
  }

  .playlist-tooltip::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: var(--border-color, #334155);
  }

  .playlist-tooltip::before {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: var(--secondary-bg, #1e293b);
    z-index: 1;
  }

  .playlist-control:hover .playlist-tooltip {
    opacity: 1;
    visibility: visible;
  }

  .playlist-header {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border-color, #334155);
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-primary, #f1f5f9);
  }

  .playlist-list {
    padding: 0.5rem 0;
  }

  :global(.playlist-item) {
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    border-left: 3px solid transparent;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.02) 0%,
      rgba(255, 255, 255, 0.05) 50%,
      rgba(255, 255, 255, 0.02) 100%
    );
    margin: 0.25rem 0;
    font-weight: 500;
    font-size: 0.85rem;
    color: var(--text-secondary, #e1e1e1);
    position: relative;
    overflow: hidden;
  }

  :global(.playlist-item::before) {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
      135deg,
      rgba(59, 130, 246, 0.1) 0%,
      rgba(96, 165, 250, 0.15) 50%,
      rgba(59, 130, 246, 0.1) 100%
    );
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
  }

  :global(.playlist-item:hover) {
    color: var(--text-primary, #f1f5f9);
    transform: translateX(2px);
    border-left-color: var(--glow-color, #60a5fa);
  }

  :global(.playlist-item:hover::before) {
    opacity: 1;
  }

  :global(.playlist-item.active) {
    background: linear-gradient(
      135deg,
      rgba(59, 130, 246, 0.15) 0%,
      rgba(96, 165, 250, 0.2) 50%,
      rgba(59, 130, 246, 0.15) 100%
    );
    border-left-color: var(--accent-bg, #3b82f6);
    color: var(--text-primary, #f1f5f9);
    font-weight: 600;
  }

  :global(.playlist-item.active::before) {
    opacity: 0;
  }

  @media (max-width: 768px) {
    .starscape-audio-player {
      gap: 0.5rem;
      padding: 0.4rem 0.6rem;
      max-width: 300px;
    }

    .track-title {
      font-size: 0.75rem;
    }

    .time-current,
    .time-total {
      font-size: 0.65rem;
    }

    .progress-bar {
      min-width: 40px;
    }
  }

  @media (max-width: 480px) {
    .starscape-audio-player {
      gap: 0.4rem;
      padding: 0.3rem 0.5rem;
      max-width: 250px;
    }

    .track-title {
      font-size: 0.7rem;
    }

    .time-current,
    .time-total {
      font-size: 0.6rem;
    }
  }
</style>

<script define:vars={{ playlist, autoplay, volume, playerId }} is:inline>
  // Starscape Simple Audio Player Implementation
  class StarscapeSimpleAudioPlayer {
    constructor(playerElement, config = {}) {
      this.playerElement = playerElement;
      this.playerId = playerElement.dataset.playerId;
      this.currentSound = null;
      this.playlists = {};
      this.currentPlaylist = "Home";
      this.currentTrackIndex = 0;
      this.isPlaying = false;
      this.isDragging = false;
      this.duration = 0;
      this.volume = config.volume || 1.0;
      this.autoplay = config.autoplay || false;
      this.progressUpdateId = null;

      // Cleanup any existing instance for this player
      this.cleanup();

      this.initializeElements();
      this.loadPlaylist("Home").then(() => {
        this.loadTrack(this.currentTrackIndex);
        this.renderPlaylistMenu();
      });
      this.attachEventListeners();

      if (this.autoplay) {
        setTimeout(() => this.play(), 1000);
      }
    }

    cleanup() {
      // Stop any existing audio immediately
      if (this.currentSound) {
        this.currentSound.stop();
        this.currentSound.unload();
        this.currentSound = null;
      }

      // Cancel any progress updates
      if (this.progressUpdateId) {
        cancelAnimationFrame(this.progressUpdateId);
        this.progressUpdateId = null;
      }

      // Reset state
      this.isPlaying = false;
      this.currentTrackIndex = 0;
      this.duration = 0;
      this.isDragging = false;
    }

    initializeElements() {
      // Use scoped element selection within this player instance
      this.playPauseBtn = this.playerElement.querySelector(
        '[data-btn="play-pause"]'
      );
      this.prevBtn = this.playerElement.querySelector('[data-btn="prev"]');
      this.nextBtn = this.playerElement.querySelector('[data-btn="next"]');
      this.trackTitle = this.playerElement.querySelector(
        '[data-element="track-title"]'
      );
      this.timeCurrent = this.playerElement.querySelector(
        '[data-element="time-current"]'
      );
      this.timeTotal = this.playerElement.querySelector(
        '[data-element="time-total"]'
      );
      this.progressBar = this.playerElement.querySelector(
        '[data-element="progress-bar"]'
      );
      this.progressFill = this.playerElement.querySelector(
        '[data-element="progress-fill"]'
      );
      this.progressHandle = this.playerElement.querySelector(
        '[data-element="progress-handle"]'
      );
      this.playIcon = this.playPauseBtn?.querySelector(".play-icon");
      this.pauseIcon = this.playPauseBtn?.querySelector(".pause-icon");
      this.volumeBtn = this.playerElement.querySelector('[data-btn="volume"]');
      this.volumeSlider = this.playerElement.querySelector(
        '[data-element="volume-slider"]'
      );
      this.volumeFill = this.playerElement.querySelector(
        '[data-element="volume-fill"]'
      );
      this.volumeHandle = this.playerElement.querySelector(
        '[data-element="volume-handle"]'
      );
      this.volumePercentage = this.playerElement.querySelector(
        '[data-element="volume-percentage"]'
      );
      this.playlistBtn = this.playerElement.querySelector(
        '[data-btn="playlist"]'
      );
      this.playlistTooltip = this.playerElement.querySelector(
        '[data-element="playlist-tooltip"]'
      );
      this.playlistList = this.playerElement.querySelector(
        '[data-element="playlist-list"]'
      );
    }

    get currentPlaylistTracks() {
      return this.playlists[this.currentPlaylist] || [];
    }

    async loadPlaylist(playlistName) {
      if (this.playlists[playlistName]) {
        return this.playlists[playlistName];
      }

      const playlistData = {
        Home: [
          {
            title: "Tranquility.mid",
            src: "/audio/playlist-home/Tranquility.mp3",
            artist: "Ambient",
            duration: "2:40",
          },
          {
            title: "MidnightExpress.mid",
            src: "/audio/playlist-home/MidnightExpress.mp3",
            artist: "Ambient",
            duration: "3:41",
          },
          {
            title: "AcrossTheUniverse.mid",
            src: "/audio/playlist-home/AcrossTheUniverse.mp3",
            artist: "Ambient",
            duration: "3:18",
          },
          {
            title: "loop-water-waves.wav",
            src: "/audio/playlist-home/loop-water-waves.wav",
            artist: "Ambient",
            duration: "3:42",
          },
        ],
        Test: [
          {
            title: "lavitz-harpoon.wave",
            src: "/audio/playlist-test/Lavitz_Harpoon_Full.mp3",
            artist: "Lavitz",
            duration: "4:15",
          },
          {
            title: "Molecules",
            src: "/audio/playlist-test/Molecules_KristoffKrane+Sadistik-compressed.mp3",
            artist: "Kristoff Krane + Sadistik",
            duration: "3:28",
          },
          {
            title: "hit_-_with_1",
            src: "/audio/playlist-test/hit_-_with_1.mp3",
            artist: "Unknown",
            duration: "2:45",
          },
          {
            title: "A Wake",
            src: "/audio/playlist-test/Eyedea_ft._Slug_-_A_Wake_(192_kbps)-compressed.mp3",
            artist: "Eyedea ft. Slug",
            duration: "4:12",
          },
        ],
      };

      if (playlistData[playlistName]) {
        this.playlists[playlistName] = playlistData[playlistName];
        return this.playlists[playlistName];
      }

      return [];
    }

    loadTrack(index) {
      const playlist = this.currentPlaylistTracks;
      if (index < 0 || index >= playlist.length) return;

      // Stop current sound first
      if (this.currentSound) {
        this.currentSound.unload();
        this.currentSound = null;
      }

      // Reset state
      this.isPlaying = false;
      this.currentTrackIndex = index;
      this.updatePlayPauseIcon();
      this.resetProgress();

      const track = playlist[index];
      if (this.trackTitle) {
        const displayTitle = track.artist
          ? `${track.title} - ${track.artist}`
          : track.title;
        this.trackTitle.textContent = displayTitle;
      }

      // Check if Howl is available
      if (typeof Howl === "undefined") {
        console.warn(
          "Howler.js not loaded. Please include Howler.js before initializing StarscapeSimpleAudioPlayer."
        );
        return;
      }

      this.currentSound = new Howl({
        src: [track.src],
        html5: true,
        volume: this.volume,
        onload: () => {
          this.duration = this.currentSound.duration();
          if (this.timeTotal) {
            this.timeTotal.textContent = this.formatTime(this.duration);
          }
        },
        onplay: () => {
          this.isPlaying = true;
          this.updatePlayPauseIcon();
          this.startProgressUpdate();
        },
        onpause: () => {
          this.isPlaying = false;
          this.updatePlayPauseIcon();
        },
        onend: () => {
          this.next();
        },
        onloaderror: () => {
          console.warn(`Failed to load: ${track.src}`);
          if (this.trackTitle) {
            this.trackTitle.textContent = `${track.title} (unavailable)`;
          }
        },
      });
    }

    resetProgress() {
      if (this.progressFill) {
        this.progressFill.style.width = "0%";
      }
      if (this.progressHandle) {
        this.progressHandle.style.left = "0%";
      }
      if (this.timeCurrent) {
        this.timeCurrent.textContent = "0:00";
      }
    }

    play() {
      if (this.currentSound) {
        this.currentSound.play();
      }
    }

    pause() {
      if (this.currentSound) {
        this.currentSound.pause();
      }
    }

    togglePlayPause() {
      if (this.isPlaying) {
        this.pause();
      } else {
        this.play();
      }
    }

    prev() {
      const wasPlaying = this.isPlaying;
      const newIndex = this.currentTrackIndex - 1;
      if (newIndex >= 0) {
        this.loadTrack(newIndex);
        if (wasPlaying) {
          setTimeout(() => this.play(), 100);
        }
      }
    }

    next() {
      const wasPlaying = this.isPlaying;
      const newIndex = this.currentTrackIndex + 1;
      const playlist = this.currentPlaylistTracks;
      if (newIndex < playlist.length) {
        this.loadTrack(newIndex);
        if (wasPlaying) {
          setTimeout(() => this.play(), 100);
        }
      }
    }

    updatePlayPauseIcon() {
      if (this.playIcon && this.pauseIcon) {
        if (this.isPlaying) {
          this.playIcon.style.display = "none";
          this.pauseIcon.style.display = "block";
        } else {
          this.playIcon.style.display = "block";
          this.pauseIcon.style.display = "none";
        }
      }
    }

    startProgressUpdate() {
      // Cancel any existing update loop
      if (this.progressUpdateId) {
        cancelAnimationFrame(this.progressUpdateId);
      }

      const updateProgress = () => {
        if (this.currentSound && this.isPlaying && !this.isDragging) {
          const seek = this.currentSound.seek() || 0;
          const progress = this.duration > 0 ? (seek / this.duration) * 100 : 0;

          if (this.progressFill) {
            this.progressFill.style.width = `${progress}%`;
          }
          if (this.progressHandle) {
            this.progressHandle.style.left = `${progress}%`;
          }
          if (this.timeCurrent) {
            this.timeCurrent.textContent = this.formatTime(seek);
          }
        }

        if (this.isPlaying) {
          this.progressUpdateId = requestAnimationFrame(updateProgress);
        }
      };
      updateProgress();
    }

    formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }

    setVolume(volume) {
      this.volume = Math.max(0, Math.min(1, volume));
      if (this.currentSound) {
        this.currentSound.volume(this.volume);
      }
      this.updateVolumeDisplay();
    }

    updateVolumeDisplay() {
      const percentage = Math.round(this.volume * 100);

      if (this.volumeFill) {
        this.volumeFill.style.width = `${percentage}%`;
      }
      if (this.volumeHandle) {
        this.volumeHandle.style.left = `${percentage}%`;
      }
      if (this.volumePercentage) {
        this.volumePercentage.textContent = `${percentage}%`;
      }
    }

    attachEventListeners() {
      if (this.playPauseBtn) {
        this.playPauseBtn.addEventListener("click", () =>
          this.togglePlayPause()
        );
      }

      if (this.prevBtn) {
        this.prevBtn.addEventListener("click", () => this.prev());
      }

      if (this.nextBtn) {
        this.nextBtn.addEventListener("click", () => this.next());
      }

      if (this.progressBar) {
        this.progressBar.addEventListener("click", (e) => {
          if (this.currentSound && this.duration) {
            const rect = this.progressBar.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const seekTime = percent * this.duration;
            this.currentSound.seek(seekTime);
          }
        });

        this.progressBar.addEventListener("mousedown", () => {
          this.isDragging = true;
          document.addEventListener("mousemove", this.handleProgressDrag);
          document.addEventListener("mouseup", this.handleProgressDragEnd);
        });
      }

      if (this.volumeSlider) {
        this.volumeSlider.addEventListener("click", (e) => {
          const rect = this.volumeSlider.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          this.setVolume(percent);
        });

        this.volumeSlider.addEventListener("mousedown", () => {
          document.addEventListener("mousemove", this.handleVolumeDrag);
          document.addEventListener("mouseup", this.handleVolumeDragEnd);
        });
      }

      // Playlist button event listener
      if (this.playlistBtn) {
        this.playlistBtn.addEventListener("click", () => {
          // Toggle playlist visibility or just let hover handle it
        });
      }

      this.updateVolumeDisplay();
    }

    handleProgressDrag = (e) => {
      if (
        this.isDragging &&
        this.progressBar &&
        this.currentSound &&
        this.duration
      ) {
        const rect = this.progressBar.getBoundingClientRect();
        const percent = Math.max(
          0,
          Math.min(1, (e.clientX - rect.left) / rect.width)
        );
        const seekTime = percent * this.duration;

        if (this.progressFill) {
          this.progressFill.style.width = `${percent * 100}%`;
        }
        if (this.progressHandle) {
          this.progressHandle.style.left = `${percent * 100}%`;
        }
        if (this.timeCurrent) {
          this.timeCurrent.textContent = this.formatTime(seekTime);
        }
      }
    };

    handleProgressDragEnd = (e) => {
      if (
        this.isDragging &&
        this.progressBar &&
        this.currentSound &&
        this.duration
      ) {
        const rect = this.progressBar.getBoundingClientRect();
        const percent = Math.max(
          0,
          Math.min(1, (e.clientX - rect.left) / rect.width)
        );
        const seekTime = percent * this.duration;
        this.currentSound.seek(seekTime);
      }

      this.isDragging = false;
      document.removeEventListener("mousemove", this.handleProgressDrag);
      document.removeEventListener("mouseup", this.handleProgressDragEnd);
    };

    handleVolumeDrag = (e) => {
      if (this.volumeSlider) {
        const rect = this.volumeSlider.getBoundingClientRect();
        const percent = Math.max(
          0,
          Math.min(1, (e.clientX - rect.left) / rect.width)
        );
        this.setVolume(percent);
      }
    };

    handleVolumeDragEnd = () => {
      document.removeEventListener("mousemove", this.handleVolumeDrag);
      document.removeEventListener("mouseup", this.handleVolumeDragEnd);
    };

    // Playlist management methods
    async switchToPlaylist(playlistName, trackIndex = 0) {
      await this.loadPlaylist(playlistName);
      if (this.playlists[playlistName]) {
        this.currentPlaylist = playlistName;
        this.currentTrackIndex = trackIndex;
        this.loadTrack(trackIndex);
        this.renderPlaylistMenu();
      }
    }

    playTrack(playlistName, trackIndex) {
      const wasPlaying = this.isPlaying;
      this.switchToPlaylist(playlistName, trackIndex);
      if (wasPlaying || !this.isPlaying) {
        setTimeout(() => this.play(), 100);
      }
    }

    renderPlaylistMenu() {
      if (!this.playlistList) return;

      this.playlistList.innerHTML = "";

      const availablePlaylists = ["Home", "Test"];

      availablePlaylists.forEach((playlistName) => {
        const isActive = playlistName === this.currentPlaylist;

        // Create simple playlist item
        const playlistItem = document.createElement("div");
        playlistItem.className = `playlist-item ${isActive ? "active" : ""}`;
        playlistItem.textContent = playlistName;

        playlistItem.addEventListener("click", () => {
          this.switchToPlaylist(playlistName);
        });

        this.playlistList?.appendChild(playlistItem);
      });
    }

    // Public method to destroy the player
    destroy() {
      this.cleanup();

      // Clean up DOM event listeners
      document.removeEventListener("mousemove", this.handleProgressDrag);
      document.removeEventListener("mouseup", this.handleProgressDragEnd);
      document.removeEventListener("mousemove", this.handleVolumeDrag);
      document.removeEventListener("mouseup", this.handleVolumeDragEnd);

      // Reset UI elements
      this.resetProgress();
      this.updatePlayPauseIcon();
      this.updateVolumeDisplay();

      if (this.trackTitle) {
        this.trackTitle.textContent = "No track loaded";
      }
    }
  }

  // Initialize this specific player instance
  function initializeStarscapePlayer() {
    if (typeof Howl === "undefined") {
      console.warn(
        "Howler.js not found. StarscapeSimpleAudioPlayer requires Howler.js to function."
      );
      return;
    }

    const playerElement = document.querySelector(
      `[data-player-id="${playerId}"]`
    );
    if (playerElement && !playerElement._starscapePlayer) {
      playerElement._starscapePlayer = new StarscapeSimpleAudioPlayer(
        playerElement,
        {
          playlist,
          autoplay,
          volume,
        }
      );
    }
  }

  // Cleanup function for page navigation
  function cleanupStarscapePlayer() {
    const playerElement = document.querySelector(
      `[data-player-id="${playerId}"]`
    );
    if (playerElement && playerElement._starscapePlayer) {
      playerElement._starscapePlayer.destroy();
      playerElement._starscapePlayer = null;
    }
  }

  // Global cleanup function to stop all audio players
  function cleanupAllStarscapePlayers() {
    // Find all starscape audio players and clean them up
    const allPlayers = document.querySelectorAll(
      ".starscape-audio-player[data-player-id]"
    );
    allPlayers.forEach((playerElement) => {
      if (playerElement._starscapePlayer) {
        playerElement._starscapePlayer.destroy();
        playerElement._starscapePlayer = null;
      }
    });

    // Also stop any Howl instances that might be lingering
    if (typeof Howl !== "undefined" && Howler) {
      Howler.stop();
      Howler.unload();
    }
  }

  // Initialize after DOM is ready and Howler.js is loaded
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(initializeStarscapePlayer, 100);
    });
  } else {
    setTimeout(initializeStarscapePlayer, 100);
  }

  // Add global cleanup listener (only once per page load)
  if (!window._starscapeCleanupAdded) {
    window._starscapeCleanupAdded = true;

    // Cleanup on page navigation for Astro
    document.addEventListener("astro:before-swap", cleanupAllStarscapePlayers);

    // Also cleanup on beforeunload as a safety net
    window.addEventListener("beforeunload", cleanupAllStarscapePlayers);
  }

  // Reinitialize after Astro navigation
  document.addEventListener("astro:after-swap", () => {
    setTimeout(initializeStarscapePlayer, 100);
  });
</script>
